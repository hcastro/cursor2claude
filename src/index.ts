#!/usr/bin/env node
/**
 * cursor2claude
 * -------------
 * CLI utility for translating Cursor IDE rule files (.md / .mdc)
 * into a single, well‚Äëstructured CLAUDE.md understood by
 * Anthropic's Claude Code CLI.
 *
 * MVP design goal: **single source of truth** ‚Äì rule lives once in
 * `.cursor/rules/`, never duplicated; CLAUDE.md imports or inlines
 * as necessary.
 *
 * Author: Henry Castro
 * Created: 2025‚Äë06‚Äë24
 *
 * @copyright
 *  This source code is licensed under the MIT license found in the
 *  LICENSE file in the root directory of this source tree.
 */

import { program } from 'commander'
import yaml from 'yaml'
import chalk from 'chalk'
import { stripIndent } from 'common-tags'
import pkg from '../package.json' with { type: 'json' }
import {
  readFileSync,
  writeFileSync,
  existsSync,
  mkdirSync,
  watch as watchFs,
} from 'fs'
import { readdir, readFile } from 'fs/promises'
import { join, relative } from 'path'

/* ------------------------------------------------------------------ */
/*  Types                                                             */
/* ------------------------------------------------------------------ */

/**
 * Minimal front‚Äëmatter contract consumed by cursor2claude.
 * File authors MAY add additional keys; they will be preserved but
 * ignored by this tool.
 */
export interface RuleFrontmatter {
  /** Short human description of the rule. */
  description?: string
  /** File glob patterns that trigger the rule (Cursor semantics). */
  globs?: string[]
  /** Global rule that always applies. */
  alwaysApply?: boolean
  /** Relative importance; only 'high' currently impacts behaviour. */
  priority?: 'high' | 'medium' | 'low'
  /** Force inline inclusion into CLAUDE.md even if long. */
  inline?: boolean
}

/** Internal wrapper for each discovered rule file. */
export interface ParsedRule {
  /** Absolute path on disk. */
  path: string
  /** Project‚Äërelative POSIX path (used in import statements). */
  relativePath: string
  /** YAML front‚Äëmatter. */
  frontmatter: RuleFrontmatter
  /** Markdown body without front‚Äëmatter. */
  content: string
  /** Raw file contents (front‚Äëmatter + body). */
  rawContent: string
}

/* ------------------------------------------------------------------ */
/*  Constants                                                         */
/* ------------------------------------------------------------------ */

const CLAUDE_MD_MARKER = '<!-- DO NOT EDIT ABOVE THIS LINE -->'
const CLAUDE_MD_HEADER = '<!-- ‚öôÔ∏è Auto-generated by cursor2claude -->'
const INLINE_THRESHOLD_LINES = 10
const VERY_SHORT_THRESHOLD_LINES = 3
const SUPPORTED_EXTENSIONS = ['.md', '.mdc']

/* ------------------------------------------------------------------ */
/*  Rule Discovery                                                    */
/* ------------------------------------------------------------------ */

/**
 * Recursively walk a directory (depth‚Äëfirst) and emit absolute file
 * paths whose extensions match SUPPORTED_EXTENSIONS.
 *
 * @param rulesDir Absolute path to `.cursor/rules/`.
 * @returns Sorted list of rule file paths.
 */
async function findRuleFiles(rulesDir: string): Promise<string[]> {
  const files: string[] = []

  async function walk(dir: string): Promise<void> {
    const entries = await readdir(dir, { withFileTypes: true })
    await Promise.all(
      entries.map(async (entry) => {
        const full = join(dir, entry.name)
        if (entry.isDirectory()) {
          await walk(full)
        } else if (
          entry.isFile() &&
          SUPPORTED_EXTENSIONS.some((ext) => entry.name.endsWith(ext))
        ) {
          files.push(full)
        }
      })
    )
  }

  await walk(rulesDir)
  return files.sort()
}

/* ------------------------------------------------------------------ */
/*  Parsing                                                           */
/* ------------------------------------------------------------------ */

/**
 * Parse a rule file, extracting YAML front‚Äëmatter if present.
 *
 * @param content File contents.
 * @param filePath Absolute file path.
 */
function parseRuleFile(content: string, filePath: string): ParsedRule {
  const relativePath = relative(process.cwd(), filePath).replace(/\\/g, '/')

  if (content.startsWith('---')) {
    // Front‚Äëmatter sentinel search (CRLF tolerant)
    const fmClose = content.search(/\r?\n---\r?\n/)
    if (fmClose !== -1) {
      const fmText = content.slice(3, fmClose).trim()
      const body = content.slice(fmClose + 5).trimStart()

      try {
        const fm = yaml.parse(fmText) as RuleFrontmatter
        return {
          path: filePath,
          relativePath,
          frontmatter: fm,
          content: body,
          rawContent: content,
        }
      } catch (err) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  YAML parse error in ${relativePath}`))
        /* fall‚Äëthrough */
      }
    }
  }

  // No / invalid front‚Äëmatter ‚Üí treat whole file as body
  return {
    path: filePath,
    relativePath,
    frontmatter: {},
    content: content.trim(),
    rawContent: content,
  }
}

/* ------------------------------------------------------------------ */
/*  Classification                                                    */
/* ------------------------------------------------------------------ */

/**
 * Group rules into logical categories for CLAUDE.md sections.
 * Keys: 'always', 'file‚Äëspecific', 'other'.
 */
function categorise(rules: ParsedRule[]): Map<string, ParsedRule[]> {
  const map = new Map<string, ParsedRule[]>([
    ['always', []],
    ['file-specific', []],
    ['other', []],
  ])

  rules.forEach((rule) => {
    if (rule.frontmatter.alwaysApply) {
      map.get('always')!.push(rule)
    } else if (rule.frontmatter.globs?.length) {
      map.get('file-specific')!.push(rule)
    } else {
      map.get('other')!.push(rule)
    }
  })

  return map
}

/* ------------------------------------------------------------------ */
/*  Inline vs Import Decision                                         */
/* ------------------------------------------------------------------ */

/**
 * Decide whether a rule should be inlined in CLAUDE.md.
 * Logic: explicit flag OR (high priority & <=10 lines) OR <=3 lines.
 */
function shouldInline(rule: ParsedRule): boolean {
  const lineCount = rule.content.split('\n').length

  if (rule.frontmatter.inline) return true
  if (
    rule.frontmatter.priority === 'high' &&
    lineCount <= INLINE_THRESHOLD_LINES
  )
    return true
  if (lineCount <= VERY_SHORT_THRESHOLD_LINES) return true
  if (lineCount <= INLINE_THRESHOLD_LINES) return true
  return false
}

/* ------------------------------------------------------------------ */
/*  CLAUDE.md Generation                                              */
/* ------------------------------------------------------------------ */

/**
 * Convert the parsed rules into a complete CLAUDE.md text,
 * preserving any user‚Äëeditable content below the MARKER.
 */
function renderClaudeMd(rules: ParsedRule[], existing?: string): string {
  const sections: string[] = [CLAUDE_MD_HEADER, '']

  /* ---------- Always‚ÄëApply ---------- */
  const cats = categorise(rules)
  const always = cats.get('always')!
  if (always.length) {
    sections.push('## üö® Always‚ÄëApply Rules')
    always.forEach((rule) => {
      if (shouldInline(rule)) {
        sections.push('', rule.content)
      } else {
        sections.push(
          `@${rule.relativePath}` +
            (rule.frontmatter.description
              ? ` <!-- ${rule.frontmatter.description} -->`
              : '')
        )
      }
    })
    sections.push('')
  }

  /* ---------- Context‚ÄëSpecific ---------- */
  const specific = cats.get('file-specific')!
  if (specific.length) {
    sections.push('## üõ†Ô∏è Context‚ÄëSpecific Rules')
    specific.forEach((rule) => {
      const context =
        rule.frontmatter.description ??
        `When working with files matching: ${rule.frontmatter.globs!.join(', ')}`
      sections.push('', `### ${context}`)
      sections.push(shouldInline(rule) ? rule.content : `@${rule.relativePath}`)
    })
    sections.push('')
  }

  /* ---------- Additional ---------- */
  const others = cats.get('other')!
  if (others.length) {
    sections.push('## üìã Additional Guidelines')
    others.forEach((rule) => {
      if (shouldInline(rule)) {
        const header = rule.frontmatter.description
          ? `### ${rule.frontmatter.description}\n`
          : ''
        sections.push('', header + rule.content)
      } else {
        sections.push(
          `@${rule.relativePath}` +
            (rule.frontmatter.description
              ? ` <!-- ${rule.frontmatter.description} -->`
              : '')
        )
      }
    })
    sections.push('')
  }

  /* ---------- Marker & User Content ---------- */
  sections.push(CLAUDE_MD_MARKER)

  if (existing) {
    const idx = existing.indexOf(CLAUDE_MD_MARKER)
    sections.push(
      idx !== -1
        ? existing.slice(idx + CLAUDE_MD_MARKER.length)
        : '\n' + existing.trimStart()
    )
  } else {
    sections.push('\n## Project Notes\n\n<!-- Add your custom notes here -->')
  }

  return sections.join('\n')
}

/* ------------------------------------------------------------------ */
/*  Sync Workflow                                                     */
/* ------------------------------------------------------------------ */

async function sync(): Promise<void> {
  const rulesDir = join(process.cwd(), '.cursor', 'rules')
  const claudePath = join(process.cwd(), 'CLAUDE.md')

  /* 1. Ensure rules directory exists */
  if (!existsSync(rulesDir)) {
    console.log(
      chalk.yellow('‚ö†Ô∏è  .cursor/rules not found ‚Äì scaffolding example.')
    )
    mkdirSync(rulesDir, { recursive: true })

    const demo = stripIndent`
      ---
      description: Example TypeScript rule
      globs: ["**/*.ts", "**/*.tsx"]
      ---

      Prefer \`interface\` over \`type\` for data shapes.
    `
    writeFileSync(join(rulesDir, 'typescript.mdc'), demo)
    console.log(
      chalk.green('‚úî Created example rule at .cursor/rules/typescript.mdc')
    )
  }

  /* 2. Discover & parse */
  console.log(chalk.blue('üîç Scanning rules‚Ä¶'))
  const files = await findRuleFiles(rulesDir)
  if (!files.length) {
    console.log(chalk.yellow('No rule files found ‚Äì nothing to sync.'))
    return
  }

  const parsed = await Promise.all(
    files.map(async (f) => parseRuleFile(await readFile(f, 'utf8'), f))
  )

  parsed.forEach((rule) =>
    console.log(
      `${shouldInline(rule) ? chalk.yellow('[inline]') : chalk.blue('[import]')} ${rule.relativePath}`
    )
  )

  /* 3. Read existing CLAUDE.md */
  const existing = existsSync(claudePath)
    ? readFileSync(claudePath, 'utf8')
    : undefined

  /* 4. Render & write */
  writeFileSync(claudePath, renderClaudeMd(parsed, existing))
  console.log(chalk.green(`‚ú® CLAUDE.md updated with ${parsed.length} rule(s)`))
}

/* ------------------------------------------------------------------ */
/*  CLI Entrypoint                                                    */
/* ------------------------------------------------------------------ */

program
  .name('cursor2claude')
  .description(
    stripIndent`
    
    Synchronise Cursor IDE rule files (.md/.mdc) with Claude Code's
    CLAUDE.md so that *one* source of truth drives *both* assistants.
    
    Typical workflow:
      1. Write or edit rules in .cursor/rules/
      2. Run \`cursor2claude sync\` (or keep it running via \`watch\`),
      3. Launch \`claude\` and benefit from the fresh context.
    
  `
  )
  .version(pkg.version, '-v, --version', 'display the current version')
  .helpOption('-h, --help', 'display help for command')
  .option('-V, --verbose', 'enable verbose output')

program
  .command('sync')
  .description('Generate‚ÄØ/ refresh CLAUDE.md in the project root.')
  .action(
    () =>
      void sync().catch((err) => {
        console.error(chalk.red('üí•'), err)
        process.exit(1)
      })
  )

program
  .command('watch')
  .description(
    'Watch .cursor/rules/**/*.{md,mdc} and run ‚Äúsync‚Äù on every change.'
  )
  .action(async () => {
    await sync()

    const dir = join(process.cwd(), '.cursor', 'rules')
    console.log(chalk.blue('üëÄ Watching .cursor/rules ‚Ä¶  (Ctrl‚ÄëC to stop)'))

    watchFs(dir, { recursive: true }, async (evt, filename) => {
      if (
        filename &&
        SUPPORTED_EXTENSIONS.some((ext) => filename.endsWith(ext))
      ) {
        console.log(
          chalk.yellow(`‚Üª  Change detected in ${filename} ‚Äì re‚Äësyncing‚Ä¶`)
        )
        await sync()
      }
    })
  })

program
  .command('status')
  .description(
    'List discovered rules, showing category and inline/import decision.'
  )
  .action(async () => {
    const dir = join(process.cwd(), '.cursor', 'rules')
    if (!existsSync(dir)) {
      console.error(chalk.red('No .cursor/rules directory in this project.'))
      process.exitCode = 2
      return
    }

    const files = await findRuleFiles(dir)
    if (!files.length) {
      console.log(chalk.yellow('No rule files found.'))
      process.exitCode = 3
      return
    }

    console.log(chalk.blue(`Found ${files.length} rule file(s):\n`))
    for (const f of files) {
      const rule = parseRuleFile(await readFile(f, 'utf8'), f)
      const cat = rule.frontmatter.alwaysApply
        ? 'always'
        : rule.frontmatter.globs?.length
          ? 'context‚Äëspecific'
          : 'other'
      console.log(
        `${shouldInline(rule) ? chalk.yellow('[inline]') : chalk.blue('[import]')} ${rule.relativePath}`
      )
      console.log(chalk.gray(`  ‚Ü≥ Category: ${cat}`))
      if (rule.frontmatter.description)
        console.log(chalk.gray(`  ‚Ü≥ ${rule.frontmatter.description}`))
      if (rule.frontmatter.globs)
        console.log(
          chalk.gray(`  ‚Ü≥ globs: ${rule.frontmatter.globs.join(', ')}`)
        )
      console.log('')
    }
  })

program.parse()
