#!/usr/bin/env node
/**
 * cursor2claude
 * -------------
 * CLI utility for translating Cursor IDE rule files (.md / .mdc)
 * into a single, wellâ€‘structured CLAUDE.md understood by
 * Anthropic's Claude Code CLI.
 *
 * MVP design goal: **single source of truth** â€“ rule lives once in
 * `.cursor/rules/`, never duplicated; CLAUDE.md imports or inlines
 * as necessary.
 *
 * Author: Henry Castro
 * Created: 2025â€‘06â€‘24
 *
 * @copyright
 *  This source code is licensed under the MIT license found in the
 *  LICENSE file in the root directory of this source tree.
 */

import { program } from 'commander'
import yaml from 'yaml'
import chalk from 'chalk'
import { stripIndent } from 'common-tags'
import pkg from '../package.json' with { type: 'json' }
import {
  readFileSync,
  writeFileSync,
  existsSync,
  mkdirSync,
  watch as watchFs,
} from 'fs'
import { readdir, readFile } from 'fs/promises'
import { join, relative } from 'path'

/* ------------------------------------------------------------------ */
/*  Types                                                             */
/* ------------------------------------------------------------------ */

/**
 * Cursor rule frontmatter based on actual Cursor implementation.
 */
export interface RuleFrontmatter {
  /** Comprehensive description for agent to determine when to apply the rule. */
  description?: string
  /** File glob patterns that trigger the rule (for auto-select rules). */
  globs?: string[] | string
  /** Whether this rule applies to every chat/Cmd+K (always rules). */
  alwaysApply?: boolean
}

/** Internal wrapper for each discovered rule file. */
export interface ParsedRule {
  /** Absolute path on disk. */
  path: string
  /** Projectâ€‘relative POSIX path (used in import statements). */
  relativePath: string
  /** YAML frontâ€‘matter. */
  frontmatter: RuleFrontmatter
  /** Markdown body without frontâ€‘matter. */
  content: string
  /** Raw file contents (frontâ€‘matter + body). */
  rawContent: string
}

/* ------------------------------------------------------------------ */
/*  Constants                                                         */
/* ------------------------------------------------------------------ */

/** Marker line in CLAUDE.md that separates generated content from user content */
const CLAUDE_MD_MARKER = '<!-- DO NOT EDIT ABOVE THIS LINE -->'

/** Header comment added to generated CLAUDE.md files */
const CLAUDE_MD_HEADER = '<!-- âš™ï¸ Auto-generated by cursor2claude -->'

/** Maximum lines for a rule to be considered for inlining */
const INLINE_THRESHOLD_LINES = 10

/** Rules with this many lines or fewer are always inlined */
const VERY_SHORT_THRESHOLD_LINES = 3

/** File extensions recognized as Cursor rule files */
const SUPPORTED_EXTENSIONS = ['.md', '.mdc']

/* ------------------------------------------------------------------ */
/*  Rule Discovery                                                    */
/* ------------------------------------------------------------------ */

/**
 * Recursively walk a directory (depthâ€‘first) and emit absolute file
 * paths whose extensions match SUPPORTED_EXTENSIONS.
 *
 * @param rulesDir Absolute path to `.cursor/rules/`.
 * @returns Sorted list of rule file paths.
 */
async function findRuleFiles(rulesDir: string): Promise<string[]> {
  const files: string[] = []

  async function walk(dir: string): Promise<void> {
    const entries = await readdir(dir, { withFileTypes: true })
    await Promise.all(
      entries.map(async (entry) => {
        const full = join(dir, entry.name)
        if (entry.isDirectory()) {
          await walk(full)
        } else if (
          entry.isFile() &&
          SUPPORTED_EXTENSIONS.some((ext) => entry.name.endsWith(ext))
        ) {
          files.push(full)
        }
      })
    )
  }

  await walk(rulesDir)
  return files.sort()
}

/* ------------------------------------------------------------------ */
/*  Parsing                                                           */
/* ------------------------------------------------------------------ */

/**
 * Parse a rule file, extracting YAML frontâ€‘matter if present.
 *
 * @param content File contents.
 * @param filePath Absolute file path.
 */
function parseRuleFile(content: string, filePath: string): ParsedRule {
  const relativePath = relative(process.cwd(), filePath).replace(/\\/g, '/')

  if (content.startsWith('---')) {
    // Frontâ€‘matter sentinel search (CRLF tolerant)
    const fmClose = content.search(/\r?\n---\r?\n/)
    if (fmClose !== -1) {
      const fmText = content.slice(3, fmClose).trim()
      const body = content.slice(fmClose + 5).trimStart()

      try {
        const fm = yaml.parse(fmText) as RuleFrontmatter
        return {
          path: filePath,
          relativePath,
          frontmatter: fm,
          content: body,
          rawContent: content,
        }
      } catch (err) {
        console.warn(chalk.yellow(`âš ï¸  YAML parse error in ${relativePath}`))
        /* fallâ€‘through */
      }
    }
  }

  // No / invalid frontâ€‘matter â†’ treat whole file as body
  return {
    path: filePath,
    relativePath,
    frontmatter: {},
    content: content.trim(),
    rawContent: content,
  }
}

/* ------------------------------------------------------------------ */
/*  Classification                                                    */
/* ------------------------------------------------------------------ */

/**
 * Normalize globs to always be an array for consistent handling.
 * @param globs - Either a string, array of strings, or undefined
 * @returns Array of glob patterns (empty if none provided)
 */
function normalizeGlobs(globs?: string[] | string): string[] {
  if (!globs) return []
  return Array.isArray(globs) ? globs : [globs]
}

/**
 * Determine rule type based solely on frontmatter fields.
 * 
 * @param rule - Parsed rule containing frontmatter and content
 * @returns Rule type matching Cursor's implementation:
 *   - 'always': alwaysApply=true (runs on every chat/cmd+k)
 *   - 'auto': has globs field (triggered by file patterns)
 *   - 'agent': has description (agent selects when to apply)
 *   - 'manual': no fields set (user manually triggers)
 */
function getRuleType(rule: ParsedRule): string {
  // Always rule: applies to every chat window and Cmd+K
  if (rule.frontmatter.alwaysApply === true) {
    return 'always'
  }
  
  // Auto-Select rule: triggered by glob patterns
  const globs = normalizeGlobs(rule.frontmatter.globs)
  if (globs.length > 0) {
    return 'auto'
  }
  
  // Agent-Selected rule: has description for context
  if (rule.frontmatter.description) {
    return 'agent'
  }
  
  // Manual rule: no frontmatter fields
  return 'manual'
}

/**
 * Group rules into logical categories for CLAUDE.md sections.
 * Based on Cursor rule types: always, auto, manual, agent
 */
function categorize(rules: ParsedRule[]): Map<string, ParsedRule[]> {
  const map = new Map<string, ParsedRule[]>([
    ['always', []],
    ['auto', []],
    ['agent', []],
    ['manual', []],
  ])

  rules.forEach((rule) => {
    const type = getRuleType(rule)
    map.get(type)!.push(rule)
  })

  return map
}

/* ------------------------------------------------------------------ */
/*  Inline vs Import Decision                                         */
/* ------------------------------------------------------------------ */

/**
 * Determine whether a rule's content should be inlined directly in CLAUDE.md
 * or referenced via @import directive.
 * 
 * @param rule - Parsed rule to evaluate
 * @returns true if content should be inlined, false for import reference
 * 
 * Decision criteria:
 * - Manual rules: Never inlined (user-triggered)
 * - Always rules: Inlined if <= 10 lines
 * - Agent rules: Import (better context via description)
 * - Auto rules: Import (file-specific context)
 * - Any rule <= 3 lines: Always inlined
 */
function shouldInline(rule: ParsedRule): boolean {
  const lineCount = rule.content.split('\n').length
  const type = getRuleType(rule)
  
  // Manual rules are never inlined (they're manually triggered)
  if (type === 'manual') return false
  
  // Always rules should be inlined if short enough
  if (type === 'always' && lineCount <= INLINE_THRESHOLD_LINES) return true
  
  // Agent-selected rules with descriptions should use imports for clarity
  if (type === 'agent' && rule.frontmatter.description) return false
  
  // Auto rules are typically file-specific and better as imports
  if (type === 'auto') return false
  
  // Very short rules can be inlined regardless of type
  if (lineCount <= VERY_SHORT_THRESHOLD_LINES) return true
  
  return false
}

/* ------------------------------------------------------------------ */
/*  CLAUDE.md Generation                                              */
/* ------------------------------------------------------------------ */

/**
 * Generate the complete CLAUDE.md content from parsed rules.
 * 
 * @param rules - Array of parsed rule files to include
 * @param existing - Current CLAUDE.md content (if exists)
 * @returns Complete CLAUDE.md content with rules organized by type
 * 
 * The generated structure includes:
 * - Header comment
 * - Always-Apply Rules section (global context)
 * - Auto-Select Rules section (file-specific)
 * - Agent-Selected Rules section (context-aware)
 * - Manual Rules section (user-triggered)
 * - Marker line
 * - Preserved user content (below marker)
 */
function renderClaudeMd(rules: ParsedRule[], existing?: string): string {
  const sections: string[] = [CLAUDE_MD_HEADER, '']

  const cats = categorize(rules)
  
  /* ---------- Always Rules (Global Context) ---------- */
  const always = cats.get('always')!
  if (always.length) {
    sections.push('## ðŸŒ Always-Apply Rules (Global Context)')
    always.forEach((rule) => {
      if (shouldInline(rule)) {
        sections.push('', rule.content)
      } else {
        sections.push(`@${rule.relativePath}`)
      }
    })
    sections.push('')
  }

  /* ---------- Auto-Select Rules (File-Specific) ---------- */
  const auto = cats.get('auto')!
  if (auto.length) {
    sections.push('## ðŸŽ¯ Auto-Select Rules (File-Specific)')
    auto.forEach((rule) => {
      const globs = normalizeGlobs(rule.frontmatter.globs)
      const globsStr = globs.length ? globs.join(', ') : 'No globs specified'
      sections.push(
        `@${rule.relativePath} <!-- Applies to: ${globsStr} -->`
      )
    })
    sections.push('')
  }

  /* ---------- Agent-Selected Rules ---------- */
  const agent = cats.get('agent')!
  if (agent.length) {
    sections.push('## ðŸ¤– Agent-Selected Rules')
    agent.forEach((rule) => {
      sections.push(
        `@${rule.relativePath}` +
          (rule.frontmatter.description
            ? ` <!-- ${rule.frontmatter.description} -->`
            : '')
      )
    })
    sections.push('')
  }
  
  /* ---------- Manual Rules ---------- */
  const manual = cats.get('manual')!
  if (manual.length) {
    sections.push('## ðŸ”§ Manual Rules (User-Triggered)')
    manual.forEach((rule) => {
      sections.push(`@${rule.relativePath} <!-- Manually triggered -->`)
    })
    sections.push('')
  }


  /* ---------- Marker & User Content ---------- */
  sections.push(CLAUDE_MD_MARKER)

  if (existing) {
    const idx = existing.indexOf(CLAUDE_MD_MARKER)
    sections.push(
      idx !== -1
        ? existing.slice(idx + CLAUDE_MD_MARKER.length)
        : '\n' + existing.trimStart()
    )
  } else {
    sections.push('\n## Project Notes\n\n<!-- Add your custom notes here -->')
  }

  return sections.join('\n')
}

/* ------------------------------------------------------------------ */
/*  Sync Workflow                                                     */
/* ------------------------------------------------------------------ */

/**
 * Main synchronization function that discovers Cursor rules and generates CLAUDE.md.
 * 
 * This function:
 * 1. Ensures .cursor/rules directory exists (creates example if missing)
 * 2. Discovers all .md/.mdc files recursively
 * 3. Parses frontmatter and categorizes rules by type
 * 4. Generates CLAUDE.md with appropriate imports/inlines
 * 5. Preserves user content below the marker line
 * 
 */
async function sync(): Promise<void> {
  const rulesDir = join(process.cwd(), '.cursor', 'rules')
  const claudePath = join(process.cwd(), 'CLAUDE.md')

  /* 1. Ensure rules directory exists */
  if (!existsSync(rulesDir)) {
    console.log(
      chalk.yellow('âš ï¸  .cursor/rules not found â€“ scaffolding example.')
    )
    mkdirSync(rulesDir, { recursive: true })

    const demo = stripIndent`
      ---
      description: Example TypeScript rule
      globs: ["**/*.ts", "**/*.tsx"]
      ---

      Prefer \`interface\` over \`type\` for data shapes.
    `
    writeFileSync(join(rulesDir, 'typescript.mdc'), demo)
    console.log(
      chalk.green('âœ” Created example rule at .cursor/rules/typescript.mdc')
    )
  }

  /* 2. Discover & parse */
  console.log(chalk.blue('ðŸ” Scanning rulesâ€¦'))
  const files = await findRuleFiles(rulesDir)
  if (!files.length) {
    console.log(chalk.yellow('No rule files found â€“ nothing to sync.'))
    return
  }

  const parsed = await Promise.all(
    files.map(async (f) => parseRuleFile(await readFile(f, 'utf8'), f))
  )

  parsed.forEach((rule) =>
    console.log(
      `${shouldInline(rule) ? chalk.yellow('[inline]') : chalk.blue('[import]')} ${rule.relativePath}`
    )
  )

  /* 3. Read existing CLAUDE.md */
  const existing = existsSync(claudePath)
    ? readFileSync(claudePath, 'utf8')
    : undefined

  /* 4. Render & write */
  writeFileSync(claudePath, renderClaudeMd(parsed, existing))
  console.log(chalk.green(`âœ¨ CLAUDE.md updated with ${parsed.length} rule(s)`))
}

/* ------------------------------------------------------------------ */
/*  CLI Entrypoint                                                    */
/* ------------------------------------------------------------------ */

program
  .name('cursor2claude')
  .description(
    stripIndent`
    
    Synchronise Cursor IDE rule files (.md/.mdc) with Claude Code's
    CLAUDE.md so that *one* source of truth drives *both* assistants.
    
    Typical workflow:
      1. Write or edit rules in .cursor/rules/
      2. Run \`cursor2claude sync\` (or keep it running via \`watch\`),
      3. Launch \`claude\` and benefit from the fresh context.
    
  `
  )
  .version(pkg.version, '-v, --version', 'display the current version')
  .helpOption('-h, --help', 'display help for command')
  .option('-V, --verbose', 'enable verbose output')

program
  .command('sync')
  .description('Generateâ€¯/ refresh CLAUDE.md in the project root.')
  .action(
    () =>
      void sync().catch((err) => {
        console.error(chalk.red('ðŸ’¥'), err)
        process.exit(1)
      })
  )

program
  .command('watch')
  .description(
    'Watch .cursor/rules/**/*.{md,mdc} and run â€œsyncâ€ on every change.'
  )
  .action(async () => {
    await sync()

    const dir = join(process.cwd(), '.cursor', 'rules')
    console.log(chalk.blue('ðŸ‘€ Watching .cursor/rules â€¦  (Ctrlâ€‘C to stop)'))

    watchFs(dir, { recursive: true }, async (_evt, filename) => {
      if (
        filename &&
        SUPPORTED_EXTENSIONS.some((ext) => filename.endsWith(ext))
      ) {
        console.log(
          chalk.yellow(`â†»  Change detected in ${filename} â€“ reâ€‘syncingâ€¦`)
        )
        await sync()
      }
    })
  })

program
  .command('status')
  .description(
    'List discovered rules, showing category and inline/import decision.'
  )
  .action(async () => {
    const dir = join(process.cwd(), '.cursor', 'rules')
    if (!existsSync(dir)) {
      console.error(chalk.red('No .cursor/rules directory in this project.'))
      process.exitCode = 2
      return
    }

    const files = await findRuleFiles(dir)
    if (!files.length) {
      console.log(chalk.yellow('No rule files found.'))
      process.exitCode = 3
      return
    }

    console.log(chalk.blue(`Found ${files.length} rule file(s):\n`))
    for (const f of files) {
      const rule = parseRuleFile(await readFile(f, 'utf8'), f)
      const type = getRuleType(rule)
      const typeLabels: Record<string, string> = {
        'always': 'Always (Global)',
        'auto': 'Auto-Select', 
        'agent': 'Agent-Selected',
        'manual': 'Manual'
      }
      const typeLabel = typeLabels[type] || type
      
      console.log(
        `${shouldInline(rule) ? chalk.yellow('[inline]') : chalk.blue('[import]')} ${rule.relativePath}`
      )
      console.log(chalk.gray(`  â†³ Type: ${typeLabel}`))
      if (rule.frontmatter.description)
        console.log(chalk.gray(`  â†³ ${rule.frontmatter.description}`))
      const globs = normalizeGlobs(rule.frontmatter.globs)
      if (globs.length)
        console.log(
          chalk.gray(`  â†³ globs: ${globs.join(', ')}`)
        )
      console.log('')
    }
  })

program.parse()
